# Strategy Developer Guide

This guide explains how to create, test, and submit trading strategies for the Noah platform.

## Table of Contents

1. [Strategy Architecture](#strategy-architecture)
2. [BaseStrategy API](#basestrategy-api)
3. [Creating a New Strategy](#creating-a-new-strategy)
4. [Strategy Parameters](#strategy-parameters)
5. [Backtesting](#backtesting)
6. [Submitting Strategies](#submitting-strategies)

## Strategy Architecture

Noah strategies are Python classes that inherit from the `BaseStrategy` abstract base class. Each strategy must implement specific methods that are called by the strategy engine.

### Key Components

1. **BaseStrategy Class**: The foundation all strategies inherit from
2. **Market Data**: Real-time data provided to strategies
3. **Signals**: Trade actions generated by strategies
4. **Execution Engine**: Handles order placement and risk management

## BaseStrategy API

### Required Methods

#### `on_tick(market_data)`
Called on each market data update.

**Parameters:**
- `market_data` (dict): Current market information

**Returns:**
- `List[Dict]`: List of trade signals

#### `on_order_fill(fill_data)`
Called when an order is filled.

**Parameters:**
- `fill_data` (dict): Information about the filled order

### Properties

#### `name`
Human-readable name of the strategy.

#### `author`
Author/creator of the strategy.

#### `description`
Brief description of the strategy's purpose and methodology.

#### `parameters`
Configuration parameters for the strategy.

#### `is_active`
Whether the strategy is currently active.

### Example Implementation

```python
from base_strategy import BaseStrategy

class SimpleMAStrategy(BaseStrategy):
    def __init__(self):
        super().__init__(
            name="Simple MA Crossover",
            author="Your Name",
            description="Buys when short MA crosses above long MA, sells when it crosses below"
        )
        self.set_parameters({
            "short_window": 50,
            "long_window": 200,
            "position_size": 0.1
        })
    
    def on_tick(self, market_data):
        signals = []
        
        # Get parameters
        short_window = self.parameters["short_window"]
        long_window = self.parameters["long_window"]
        position_size = self.parameters["position_size"]
        
        # Example trading logic (simplified)
        if market_data["sma_short"] > market_data["sma_long"]:
            signals.append({
                "action": "BUY",
                "symbol": market_data["symbol"],
                "amount": position_size
            })
        elif market_data["sma_short"] < market_data["sma_long"]:
            signals.append({
                "action": "SELL",
                "symbol": market_data["symbol"],
                "amount": position_size
            })
            
        return signals
    
    def on_order_fill(self, fill_data):
        # Log or handle filled orders
        print(f"Order filled: {fill_data}")
```

## Creating a New Strategy

### 1. Set Up Your Development Environment

```bash
# Clone the Noah repository
git clone https://github.com/afeezaziz/Noah.git
cd Noah

# Install dependencies
pip install -r requirements.txt
```

### 2. Create Your Strategy File

Create a new Python file in the `strategies` directory:

```python
# strategies/my_strategy.py
from base_strategy import BaseStrategy

class MyStrategy(BaseStrategy):
    def __init__(self):
        super().__init__(
            name="My Custom Strategy",
            author="Your Name",
            description="A brief description of what your strategy does"
        )
        # Set default parameters
        self.set_parameters({
            "param1": 10,
            "param2": 0.5
        })
    
    def on_tick(self, market_data):
        # Implement your trading logic here
        signals = []
        
        # Example logic
        if market_data["condition"]:
            signals.append({
                "action": "BUY",
                "symbol": market_data["symbol"],
                "amount": self.parameters["param2"]
            })
            
        return signals
    
    def on_order_fill(self, fill_data):
        # Handle order fills
        pass
```

### 3. Strategy Parameters

All parameters should be configurable and have sensible defaults. Users can adjust these parameters when activating a strategy.

```python
# Good parameter design
self.set_parameters({
    "lookback_period": 14,        # Number of periods to look back
    "threshold": 0.02,            # 2% threshold for action
    "position_size": 0.1,         # 10% of portfolio
    "stop_loss": 0.05,            # 5% stop loss
    "take_profit": 0.10           # 10% take profit
})
```

## Backtesting

### Running Backtests

Noah provides a built-in backtesting engine to test your strategies:

```python
from backtester import Backtester
from strategies.my_strategy import MyStrategy

# Create strategy and backtester
strategy = MyStrategy()
backtester = Backtester()

# Run backtest
results = backtester.run_backtest(
    strategy=strategy,
    symbol="BTC",
    start_date=datetime(2023, 1, 1),
    end_date=datetime(2023, 12, 31)
)

# View results
print(f"Total Return: {results['total_return_percent']}")
print(f"Sharpe Ratio: {results['sharpe_ratio']}")
print(f"Max Drawdown: {results['max_drawdown_percent']}")
```

### Performance Metrics

The backtester provides several key performance metrics:

- **Total Return**: Overall profitability
- **Sharpe Ratio**: Risk-adjusted return
- **Max Drawdown**: Largest peak-to-trough decline
- **Win Rate**: Percentage of profitable trades
- **Average Trade**: Average profit per trade

## Submitting Strategies

### 1. Code Quality

Ensure your strategy follows best practices:

- Proper error handling
- Clear documentation
- Efficient code
- Sensible parameter defaults

### 2. Testing

Before submitting:

1. Run backtests with various market conditions
2. Test edge cases
3. Verify parameter sensitivity
4. Check for potential bugs

### 3. Documentation

Include clear documentation:

```python
class MyStrategy(BaseStrategy):
    """
    A detailed description of the strategy.
    
    This strategy uses [methodology] to identify [type of opportunities].
    It's best suited for [market conditions].
    
    Parameters:
    - param1 (int): Description of parameter 1
    - param2 (float): Description of parameter 2
    
    Author: Your Name
    Version: 1.0
    """
    # Implementation...
```

### 4. Submission Process

1. Fork the Noah repository
2. Add your strategy to the `strategies` directory
3. Create a pull request with:
   - Your strategy code
   - Updated documentation
   - Backtest results
   - Test cases

### 5. Review Process

All submissions are reviewed for:

- **Correctness**: Does the strategy work as intended?
- **Security**: Are there any potential vulnerabilities?
- **Performance**: Is the code efficient?
- **Documentation**: Is it well-documented?
- **Originality**: Does it provide unique value?

## Best Practices

### 1. Risk Management

Always implement proper risk management:

```python
def on_tick(self, market_data):
    signals = []
    
    # Check position limits
    if self.current_position < self.max_position:
        # Generate signals
        pass
    
    return signals
```

### 2. Error Handling

Handle potential errors gracefully:

```python
def on_tick(self, market_data):
    try:
        # Strategy logic
        if "price" not in market_data:
            raise ValueError("Missing price data")
        # ... rest of logic
    except Exception as e:
        # Log error and continue
        print(f"Strategy error: {e}")
        return []
```

### 3. Performance

Optimize for performance:

- Cache expensive calculations
- Avoid unnecessary data processing
- Use efficient data structures

## Example Strategies

### Mean Reversion Strategy

```python
class MeanReversionStrategy(BaseStrategy):
    def __init__(self):
        super().__init__(
            name="Mean Reversion",
            author="Noah Team",
            description="Buys when price deviates below moving average, sells when it deviates above"
        )
        self.set_parameters({
            "window": 20,
            "std_dev_multiplier": 2.0,
            "position_size": 0.1
        })
    
    def on_tick(self, market_data):
        signals = []
        
        window = self.parameters["window"]
        std_dev_mult = self.parameters["std_dev_multiplier"]
        position_size = self.parameters["position_size"]
        
        # Calculate z-score
        z_score = (market_data["price"] - market_data["sma"]) / market_data["std_dev"]
        
        if z_score < -std_dev_mult:
            # Price is below mean, buy
            signals.append({
                "action": "BUY",
                "symbol": market_data["symbol"],
                "amount": position_size
            })
        elif z_score > std_dev_mult:
            # Price is above mean, sell
            signals.append({
                "action": "SELL",
                "symbol": market_data["symbol"],
                "amount": position_size
            })
            
        return signals
```

### Momentum Strategy

```python
class MomentumStrategy(BaseStrategy):
    def __init__(self):
        super().__init__(
            name="Momentum",
            author="Noah Team",
            description="Follows price trends with RSI indicator"
        )
        self.set_parameters({
            "rsi_period": 14,
            "overbought": 70,
            "oversold": 30,
            "position_size": 0.1
        })
    
    def on_tick(self, market_data):
        signals = []
        
        rsi = market_data["rsi"]
        overbought = self.parameters["overbought"]
        oversold = self.parameters["oversold"]
        position_size = self.parameters["position_size"]
        
        if rsi < oversold:
            # Oversold, buy
            signals.append({
                "action": "BUY",
                "symbol": market_data["symbol"],
                "amount": position_size
            })
        elif rsi > overbought:
            # Overbought, sell
            signals.append({
                "action": "SELL",
                "symbol": market_data["symbol"],
                "amount": position_size
            })
            
        return signals
```

## API Reference

### Market Data Fields

Available fields in the `market_data` dictionary:

- `symbol` (str): Trading symbol
- `price` (float): Current price
- `timestamp` (str): ISO format timestamp
- `sma` (float): Simple moving average
- `ema` (float): Exponential moving average
- `rsi` (float): Relative Strength Index
- `volume` (float): Trading volume
- `high` (float): High price
- `low` (float): Low price

### Signal Format

Trade signals should be dictionaries with the following structure:

```python
{
    "action": "BUY" or "SELL",
    "symbol": "BTC",
    "amount": 0.1,  # Position size as fraction of portfolio
    "limit_price": 65000.0,  # Optional limit price
    "stop_loss": 63000.0,    # Optional stop loss price
    "take_profit": 67000.0   # Optional take profit price
}
```

### Fill Data Fields

Available fields in the `fill_data` dictionary:

- `order_id` (str): Unique order identifier
- `symbol` (str): Trading symbol
- `action` (str): "BUY" or "SELL"
- `price` (float): Fill price
- `amount` (float): Fill amount
- `timestamp` (str): Fill timestamp
- `commission` (float): Trading fees

---
*Noah - The Autonomous Financial Agent*